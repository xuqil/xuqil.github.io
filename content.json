{"meta":{"title":"SNH","subtitle":"SNH博客","description":"SNHGB","author":"xuqilong","url":"http://xuqilong.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-01-13T16:32:04.220Z","updated":"2020-01-13T16:32:04.220Z","comments":true,"path":"404.html","permalink":"http://xuqilong.com/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-01-14T05:20:28.533Z","updated":"2020-01-14T05:20:28.533Z","comments":true,"path":"about/index.html","permalink":"http://xuqilong.com/about/index.html","excerpt":"","text":"你好"},{"title":"所有分类","date":"2020-01-13T16:33:46.452Z","updated":"2020-01-13T16:33:46.452Z","comments":true,"path":"categories/index.html","permalink":"http://xuqilong.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-01-14T05:20:02.588Z","updated":"2020-01-14T05:20:02.588Z","comments":true,"path":"friends/index.html","permalink":"http://xuqilong.com/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-01-13T16:34:07.809Z","updated":"2020-01-13T16:34:07.809Z","comments":true,"path":"tags/index.html","permalink":"http://xuqilong.com/tags/index.html","excerpt":"","text":""},{"title":"项目","date":"2020-01-14T05:16:31.368Z","updated":"2020-01-14T05:16:31.368Z","comments":true,"path":"projects/index.html","permalink":"http://xuqilong.com/projects/index.html","excerpt":"","text":""}],"posts":[{"title":"Django REST framework:Routers","slug":"Routers","date":"2020-01-14T16:37:52.133Z","updated":"2020-01-14T16:56:35.223Z","comments":true,"path":"2020-01-15-Routers.html","link":"","permalink":"http://xuqilong.com/2020-01-15-Routers.html","excerpt":"资源路由允许您快速声明给定资源控制器的所有通用路由。无需为索引声明单独的路由，而是在单行代码中声明资源丰富的路由。","text":"资源路由允许您快速声明给定资源控制器的所有通用路由。无需为索引声明单独的路由，而是在单行代码中声明资源丰富的路由。 Routers 资源路由允许您快速声明给定资源控制器的所有通用路由。无需为索引声明单独的路由，而是在单行代码中声明资源丰富的路由。 — Ruby on Rails文档 一些Web框架（例如Rails）提供了自动确定应用程序的URL应如何映射到处理传入请求的逻辑的功能。 REST框架增加了对将自动URL路由到Django的支持，并为您提供了一种简单，快速且一致的方式将视图逻辑连接到一组URL。 用法这是一个使用的简单URL conf的示例SimpleRouter。 123456from rest_framework import routersrouter = routers.SimpleRouter()router.register(r'users', UserViewSet)router.register(r'accounts', AccountViewSet)urlpatterns = router.urls 该方法有两个强制性参数register()： prefix -用于这组路由的URL前缀。 viewset -视图集类。 （可选）您还可以指定其他参数： basename-用于创建的URL名称的基础。如果未设置，则基名称将基于queryset视图集的属性自动生成（如果有）。请注意，如果视图集不包含queryset属性，则必须basename在注册视图集时进行设置。 上面的示例将生成以下URL模式： 网址格式：^users/$ 名称：&#39;user-list&#39; 网址格式：^users/{pk}/$ 名称：&#39;user-detail&#39; 网址格式：^accounts/$ 名称：&#39;account-list&#39; 网址格式：^accounts/{pk}/$ 名称：&#39;account-detail&#39; 注意：该basename参数用于指定视图名称模式的初始部分。在上面的示例中，这就是“ user或” account部分。 通常，您不需要指定basename参数，但是如果您有一个定义了自定义get_queryset方法的视图.queryset集，则该视图集可能没有属性集。如果尝试注册该视图集，则会看到类似以下错误： 1'basename' argument not specified, and could not automatically determine the name from the viewset, as it does not have a '.queryset' attribute. 这意味着basename注册视图集时需要显式设置参数，因为无法从模型名称自动确定该参数。 include与路由器一起使用.urls路由器实例上的属性只是URL模式的标准列表。关于如何包含这些URL，有很多不同的样式。 例如，您可以追加router.urls到现有视图的列表中… 123456789router = routers.SimpleRouter()router.register(r'users', UserViewSet)router.register(r'accounts', AccountViewSet)urlpatterns = [ url(r'^forgot-password/$', ForgotPasswordFormView.as_view()),]urlpatterns += router.urls 另外，您也可以使用Django的include功能，例如… 1234urlpatterns = [ url(r'^forgot-password/$', ForgotPasswordFormView.as_view()), url(r'^', include(router.urls)),] 您可以使用include应用程序名称空间： 1234urlpatterns = [ url(r'^forgot-password/$', ForgotPasswordFormView.as_view()), url(r'^api/', include((router.urls, 'app_name'))),] 或应用程序和实例名称空间： 1234urlpatterns = [ url(r'^forgot-password/$', ForgotPasswordFormView.as_view()), url(r'^api/', include((router.urls, 'app_name'), namespace='instance_name')),] 有关更多详细信息，请参见Django的URL名称空间文档和includeAPI参考。 注意：如果将命名空间与超链接的序列化程序一起使用，则还需要确保view_name序列化程序上的所有参数都能正确反映名称空间。在上面的示例中，您需要包括一个参数，例如view_name=&#39;app_name:user-detail&#39;超链接到用户详细信息视图的序列化程序字段的参数 。 自动view_name生成使用的模式%(model_name)-detail。除非您的模型名称实际发生冲突，否则在使用超链接序列化程序时最好不要为 Django REST Framework视图命名。 额外操作的路由视图集可以通过用装饰器装饰方法来标记用于路由的额外操作@action。这些额外的动作将包含在生成的路线中。例如，给定类的set_password方法UserViewSet： 123456789from myapp.permissions import IsAdminOrIsSelffrom rest_framework.decorators import actionclass UserViewSet(ModelViewSet): ... @action(methods=['post'], detail=True, permission_classes=[IsAdminOrIsSelf]) def set_password(self, request, pk=None): ... 将生成以下路线： 网址格式： ^users/{pk}/set_password/$ 网址名称： &#39;user-set-password&#39; 默认情况下，URL模式基于方法命名，URL名称是ViewSet.basename和连字符方法名的组合。如果您不想对这些值中的任何一个使用默认值，您可以改为向@action 装饰器提供url_path和 url_name参数。 例如，如果要将我们的自定义操作的URL更改为^users/{pk}/change-password/$，则可以编写： 12345678910from myapp.permissions import IsAdminOrIsSelffrom rest_framework.decorators import actionclass UserViewSet(ModelViewSet): ... @action(methods=['post'], detail=True, permission_classes=[IsAdminOrIsSelf], url_path='change-password', url_name='change_password') def set_password(self, request, pk=None): ... 上面的示例现在将生成以下URL模式： 网址路径： ^users/{pk}/change-password/$ 网址名称： &#39;user-change_password&#39; API指南SimpleRouter该路由器包括一套标准的途径list，create，retrieve，update，partial_update和destroy行动。视图集还可以使用@action装饰器标记路由的其他方法。 URL Style HTTP Method Action URL Name {prefix}/ GET list {basename}-list POST create {prefix}/{url_path}/ GET, 或由methods参数指定 @action(detail=False) decorated method {basename}-{url_name} {prefix}/{lookup}/ GET retrieve {basename}-detail PUT update PATCH partial_update DELETE destroy {prefix}/{lookup}/{url_path}/ GET, 或由methods参数指定 @action(detail=True) decorated method {basename}-{url_name} 默认情况下，SimpleRouter创建的url会附加一个斜杠。在实例化路由器时，可以通过将尾部的斜杠参数设置为False来修改此行为。例如： 1router = SimpleRouter(trailing_slash=False) 尾部的斜杠在Django中是常规的，但在其他一些框架（例如Rails）中默认不使用。尽管有些JavaScript框架可能期望使用特定的路由样式，但是选择使用哪种样式在很大程度上取决于首选项。 路由器将匹配包含除斜杠和句点字符以外的任何字符的查找值。对于更严格（或更宽松）的查找模式，请lookup_value_regex在视图集上设置属性。例如，您可以将查找限制为有效的UUID： 123class MyModelViewSet(mixins.RetrieveModelMixin, viewsets.GenericViewSet): lookup_field = 'my_model_id' lookup_value_regex = '[0-9a-f]&#123;32&#125;' DefaultRouter该路由器与SimpleRouter上面类似，但是还包括一个默认的API根视图，该根视图返回一个响应，其中包含指向所有列表视图的超链接。它还为可选.json样式格式后缀生成路由。 URL Style HTTP Method Action URL Name [.format] GET 自动生成的根视图 api-root {prefix}/[.format] GET list {basename}-list POST create {prefix}/{url_path}/[.format] GET, 或由“methods”参数指定 @action(detail=False) decorated method {basename}-{url_name} {prefix}/{lookup}/[.format] GET retrieve {basename}-detail PUT update PATCH partial_update DELETE destroy {prefix}/{lookup}/{url_path}/[.format] GET, 或由“methods”参数指定 @action(detail=True) decorated method {basename}-{url_name} 与SimpleRouter一样，在实例化路由器时，可以通过将trailing_slash参数设置为False来删除URL路由上的尾部斜杠。 1router = DefaultRouter(trailing_slash=False) 自定义路由器实施定制路由器并不是您经常需要做的事情，但是如果您对API的URL的结构有特定要求，这将很有用。这样做可以使您以可重用的方式封装URL结构，从而确保您不必为每个新视图明确编写URL模式。 实现自定义路由器的最简单方法是将现有路由器类之一作为子类。该.routes属性用于模板化将映射到每个视图集的URL模式。该.routes属性是Route命名元组的列表。 Route命名元组的参数为： url：一个字符串，代表要路由的URL。可能包含以下格式字符串： {prefix} -用于这组路由的URL前缀。 {lookup} -用于与单个实例匹配的查找字段。 {trailing_slash}-根据trailing_slash参数，是’/‘还是空字符串。 mapping：HTTP方法名称到视图方法的映射 name：reverse呼叫中使用的URL名称。可能包含以下格式字符串： {basename} -用于创建的URL名称的基础。 initkwargs：实例化视图时应传递的所有其他参数的字典。请注意，detail，basename，和suffix参数保留给视图集中内省和也使用可浏览的API生成视图名称和面包屑链接。 自定义动态路线您还可以自定义@action装饰器的路由方式。DynamicRoute在.routes列表中包括命名的元组，将detail参数设置为适用于基于列表的路由和基于详细信息的路由。除了detail，参数为DynamicRoute： url：一个字符串，代表要路由的URL。可能包含与相同的格式字符串Route，并且另外接受{url_path}格式字符串。 name：reverse呼叫中使用的URL名称。可能包含以下格式字符串： {basename} -用于创建的URL名称的基础。 {url_name}- url_name提供给@action。 initkwargs：实例化视图时应传递的所有其他参数的字典。 例以下示例将仅路由到list和retrieve操作，并且不使用尾部斜杠约定。 12345678910111213141516171819202122232425262728from rest_framework.routers import Route, DynamicRoute, SimpleRouterclass CustomReadOnlyRouter(SimpleRouter): \"\"\" A router for read-only APIs, which doesn't use trailing slashes. \"\"\" routes = [ Route( url=r'^&#123;prefix&#125;$', mapping=&#123;'get': 'list'&#125;, name='&#123;basename&#125;-list', detail=False, initkwargs=&#123;'suffix': 'List'&#125; ), Route( url=r'^&#123;prefix&#125;/&#123;lookup&#125;$', mapping=&#123;'get': 'retrieve'&#125;, name='&#123;basename&#125;-detail', detail=True, initkwargs=&#123;'suffix': 'Detail'&#125; ), DynamicRoute( url=r'^&#123;prefix&#125;/&#123;lookup&#125;/&#123;url_path&#125;$', name='&#123;basename&#125;-&#123;url_name&#125;', detail=True, initkwargs=&#123;&#125; ) ] 让我们看一下我们CustomReadOnlyRouter将为简单视图集生成的路线。 views.py： 1234567891011121314151617class UserViewSet(viewsets.ReadOnlyModelViewSet): \"\"\" A viewset that provides the standard actions \"\"\" queryset = User.objects.all() serializer_class = UserSerializer lookup_field = 'username' @action(detail=True) def group_names(self, request, pk=None): \"\"\" Returns a list of all the group names that the given user belongs to. \"\"\" user = self.get_object() groups = user.groups.all() return Response([group.name for group in groups]) urls.py： 123router = CustomReadOnlyRouter()router.register('users', UserViewSet)urlpatterns = router.urls 将生成以下映射… URL HTTP Method Action URL Name /users GET list user-list /users/{username} GET retrieve user-detail /users/{username}/group_names GET group_names user-group-names 有关设置.routes属性的另一个示例，请参见SimpleRouter该类的源代码。 高级自定义路由器如果要提供完全自定义的行为，则可以重写BaseRouter和重写该get_urls(self)方法。该方法应检查已注册的视图集并返回URL模式列表。可以通过访问self.registry属性来检查已注册的前缀，视图集和基本名称元组。 您可能还想覆盖该get_default_basename(self, viewset)方法，或者basename在向路由器注册视图集时始终显式设置参数。 第三方软件包以下第三方软件包也可用。 DRF嵌套路由器的DRF-嵌套的路由器包提供路由器和关系字段用于与嵌套资源工作。 ModelRouter（wq.db.rest）所述wq.db包提供了一个先进ModelRouter延伸类（和单个实例）DefaultRouter用register_model()的API。就像Django一样admin.site.register，唯一需要的参数rest.router.register_model是模型类。可以从模型和全局配置中推断出URL前缀，序列化程序和视图集的合理默认值。 1234from wq.db import restfrom myapp.models import MyModelrest.router.register_model(MyModel) DRF扩展该DRF-extensions软件包提供了路由器创建嵌套viewsets，收藏级控制器与定制的端点名。","categories":[{"name":"Django","slug":"Django","permalink":"http://xuqilong.com/categories/Django/"},{"name":"Django-Rest-framework","slug":"Django/Django-Rest-framework","permalink":"http://xuqilong.com/categories/Django/Django-Rest-framework/"}],"tags":[{"name":"restful","slug":"restful","permalink":"http://xuqilong.com/tags/restful/"},{"name":"Routers","slug":"Routers","permalink":"http://xuqilong.com/tags/Routers/"},{"name":"Django","slug":"Django","permalink":"http://xuqilong.com/tags/Django/"},{"name":"Django-Rest-framework","slug":"Django-Rest-framework","permalink":"http://xuqilong.com/tags/Django-Rest-framework/"}]},{"title":"Django REST framework:ViewsSets","slug":"ViewsSets","date":"2020-01-14T16:37:47.416Z","updated":"2020-01-14T16:56:04.429Z","comments":true,"path":"2020-01-15-ViewsSets.html","link":"","permalink":"http://xuqilong.com/2020-01-15-ViewsSets.html","excerpt":"在路由确定了要用于请求的控制器之后，您的控制器负责理解请求并产生适当的输出。","text":"在路由确定了要用于请求的控制器之后，您的控制器负责理解请求并产生适当的输出。 ViewSets 在路由确定了要用于请求的控制器之后，您的控制器负责理解请求并产生适当的输出。 — Ruby on Rails文档 ViewSets:视图集 Django REST框架允许您在称为的单个类中将一组相关视图的逻辑组合在一起ViewSet。在其他框架中，您可能还会发现概念上类似的实现，这些实现的名称类似于“资源”或“控制器”。 ViewSet类只是一种类型的基于类的视图，即不提供任何方法的处理程序，例如.get()或.post()，而是提供操作，如.list()和.create()。 视图集的方法处理程序仅在完成视图时使用.as_view（）方法绑定到相应的操作。 通常，您将向路由器集注册视图集，而不是在urlconf中的视图集中显式注册视图，而是自动为您确定urlconf。 例让我们定义一个简单的视图集，可用于列出或检索系统中的所有用户。 1234567891011121314151617181920from django.contrib.auth.models import Userfrom django.shortcuts import get_object_or_404from myapps.serializers import UserSerializerfrom rest_framework import viewsetsfrom rest_framework.response import Responseclass UserViewSet(viewsets.ViewSet): \"\"\" A simple ViewSet for listing or retrieving users. \"\"\" def list(self, request): queryset = User.objects.all() serializer = UserSerializer(queryset, many=True) return Response(serializer.data) def retrieve(self, request, pk=None): queryset = User.objects.all() user = get_object_or_404(queryset, pk=pk) serializer = UserSerializer(user) return Response(serializer.data) 如果需要，可以将此viewset绑定到两个单独的视图中，如下所示： 12user_list = UserViewSet.as_view(&#123;'get': 'list'&#125;)user_detail = UserViewSet.as_view(&#123;'get': 'retrieve'&#125;) 通常，我们不这样做，而是向路由器注册视图集，并允许自动生成urlconf。 123456from myapp.views import UserViewSetfrom rest_framework.routers import DefaultRouterrouter = DefaultRouter()router.register(r'users', UserViewSet, basename='user')urlpatterns = router.urls 您通常不希望编写自己的视图集，而是要使用提供默认行为集的现有基类。例如： 123456class UserViewSet(viewsets.ModelViewSet): \"\"\" A viewset for viewing and editing user instances. \"\"\" serializer_class = UserSerializer queryset = User.objects.all() 与使用ViewSet类相比，使用类有两个主要优点View。 重复的逻辑可以合并为一个类。在上面的示例中，我们只需要指定queryset一次，它将在多个视图中使用。 通过使用路由器，我们不再需要自己处理URL conf。 两者都需要权衡。使用常规视图和URL conf更加明确，并给您更多的控制权。如果您想快速启动并运行，或者当您使用大型API并希望在整个过程中实施一致的URL配置，则ViewSets很有帮助。 ViewSet操作REST框架随附的默认路由器将为一组标准的 create/retrieve/update/destroy 样式操作提供路由，如下所示： 1234567891011121314151617181920212223242526class UserViewSet(viewsets.ViewSet): \"\"\" Example empty viewset demonstrating the standard actions that will be handled by a router class. If you're using format suffixes, make sure to also include the `format=None` keyword argument for each action. \"\"\" def list(self, request): pass def create(self, request): pass def retrieve(self, request, pk=None): pass def update(self, request, pk=None): pass def partial_update(self, request, pk=None): pass def destroy(self, request, pk=None): pass 自省 ViewSet 动作在分发期间，可以使用以下属性ViewSet。 basename -用于创建的URL名称的基础。 action-当前动作的名称（例如list，create）。 detail -布尔值，指示是否为列表视图或详细信息视图配置了当前操作。 suffix-视图集类型的显示后缀-镜像detail属性。 name-视图集的显示名称。此参数与互斥suffix。 description -视图集单个视图的显示描述。 您可以检查这些属性以根据当前操作调整行为。例如，您可以将权限限制为除以下list类似操作外的所有权限： 123456789def get_permissions(self): \"\"\" Instantiates and returns the list of permissions that this view requires. \"\"\" if self.action == 'list': permission_classes = [IsAuthenticated] else: permission_classes = [IsAdmin] return [permission() for permission in permission_classes] 标记路由的额外操作如果您具有可路由的临时方法，则可以使用@action装饰器将它们标记为可路由的。像常规操作一样，额外的操作可能打算用于单个对象或整个集合。为了表明这一点，请将detail参数设置为True或False。路由器将相应地配置其URL模式。例如，DefaultRouter将配置详细信息操作以包含pk在其URL模式中。 额外操作的更完整示例： 123456789101112131415161718192021222324252627282930313233343536from django.contrib.auth.models import Userfrom rest_framework import status, viewsetsfrom rest_framework.decorators import actionfrom rest_framework.response import Responsefrom myapp.serializers import UserSerializer, PasswordSerializerclass UserViewSet(viewsets.ModelViewSet): \"\"\" A viewset that provides the standard actions \"\"\" queryset = User.objects.all() serializer_class = UserSerializer @action(detail=True, methods=['post']) def set_password(self, request, pk=None): user = self.get_object() serializer = PasswordSerializer(data=request.data) if serializer.is_valid(): user.set_password(serializer.data['password']) user.save() return Response(&#123;'status': 'password set'&#125;) else: return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) @action(detail=False) def recent_users(self, request): recent_users = User.objects.all().order_by('-last_login') page = self.paginate_queryset(recent_users) if page is not None: serializer = self.get_serializer(page, many=True) return self.get_paginated_response(serializer.data) serializer = self.get_serializer(recent_users, many=True) return Response(serializer.data) 装饰器可以另外接受仅为路由视图设置的额外参数。例如： 123@action(detail=True, methods=['post'], permission_classes=[IsAdminOrIsSelf])def set_password(self, request, pk=None): ... 在action装饰后，系统会GET默认请求，也可以接受设定其他HTTP方法methods的参数。例如： 123@action(detail=True, methods=['post', 'delete'])def unset_password(self, request, pk=None): ... 然后，两个新操作将在网址^users/{pk}/set_password/$和^users/{pk}/unset_password/$ 要查看所有其他操作，请调用.get_extra_actions()方法。 路由其他HTTP方法以执行其他操作额外的操作可以将其他HTTP方法映射到单独的ViewSet方法。例如，上述密码设置/取消方法可以合并为一条路由。请注意，其他映射不接受参数。 123456789@action(detail=True, methods=['put'], name='Change Password')def password(self, request, pk=None): \"\"\"Update the user's password.\"\"\" ...@password.mapping.deletedef delete_password(self, request, pk=None): \"\"\"Delete the user's password.\"\"\" ... 反转URL如果需要获取操作的URL，请使用.reverse_action()方法。这是的便利包装reverse()，可自动传递视图的request对象并url_name在.basename属性之前添加。 请注意，basename路由器在ViewSet注册过程中提供。如果您不使用路由器，则必须basename为该.as_view()方法提供参数。 使用上一节中的示例： 12&gt;&gt;&gt; view.reverse_action('set-password', args=['1'])'http://localhost:8000/api/users/1/set_password' 或者，您可以使用装饰器url_name设置的属性@action。 12&gt;&gt;&gt; view.reverse_action(view.set_password.url_name, args=['1'])'http://localhost:8000/api/users/1/set_password' 的url_name参数.reverse_action()应与@action装饰器匹配相同的参数。此外，此方法可用于撤消默认操作，例如list和create。 API参考ViewSet视图集ViewSet类继承自APIView。您可以使用任何标准的属性，如permission_classes，authentication_classes以控制在视图集的API政策。 本ViewSet类不提供任何操作实现。为了使用一个ViewSet类，您将覆盖该类并显式定义动作实现。 GenericViewSet通用视图集GenericViewSet继承自GenericAPIView，并提供了默认设置get_object，get_queryset方法及其他通用视图基地的行为，但不包括默认情况下，任何动作。 为了使用一个GenericViewSet类，您将覆盖该类并混合所需的mixin类，或显式定义操作实现。 ModelViewSet模型视图集ModelViewSet继承自GenericAPIView，并包括用于各种动作实现方式中，通过在各种混入类的行为混合。 由提供的动作ModelViewSet类是.list()，.retrieve()， .create()，.update()，.partial_update()，和.destroy()。 例由于ModelViewSet拓展了 GenericAPIView，通常需要至少提供queryset和serializer_class属性。例如： 1234567class AccountViewSet(viewsets.ModelViewSet): \"\"\" A simple ViewSet for viewing and editing accounts. \"\"\" queryset = Account.objects.all() serializer_class = AccountSerializer permission_classes = [IsAccountAdminOrReadOnly] 请注意，您可以使用所提供的任何标准属性或方法替代GenericAPIView。例如，要使用ViewSet动态确定其应操作的查询集的，您可以执行以下操作： 12345678910class AccountViewSet(viewsets.ModelViewSet): \"\"\" A simple ViewSet for viewing and editing the accounts associated with the user. \"\"\" serializer_class = AccountSerializer permission_classes = [IsAccountAdminOrReadOnly] def get_queryset(self): return self.request.user.accounts.all() 但是，请注意，从视图集中删除queryset属性后，任何关联的路由器都将无法自动派生模型的basename，因此您必须将basename kwarg指定为路由器注册中的一部分。 还要注意，尽管默认情况下此类提供了完整的create / list / retrieve / update / destroy操作集，但是您可以使用标准权限类来限制可用的操作。 ReadOnlyModelViewSet该ReadOnlyModelViewSet类也继承GenericAPIView。与ModelViewSet一样，它也包含各种动作的实现，但与ModelViewSet只提供“只读”动作不同，.list()和.retrieve()。 例与一样ModelViewSet，您通常至少需要提供querysetand serializer_class属性。例如： 123456class AccountViewSet(viewsets.ReadOnlyModelViewSet): \"\"\" A simple ViewSet for viewing accounts. \"\"\" queryset = Account.objects.all() serializer_class = AccountSerializer 同样，ModelViewSet您可以使用的任何标准属性和方法替代GenericAPIView。 自定义ViewSet基类您可能需要提供ViewSet没有完整ModelViewSet动作集或以其他方式自定义行为的自定义类。 例要创建基础视图集类，提供create，list和retrieve操作，继承GenericViewSet和混入所需的操作： 12345678910111213from rest_framework import mixinsclass CreateListRetrieveViewSet(mixins.CreateModelMixin, mixins.ListModelMixin, mixins.RetrieveModelMixin, viewsets.GenericViewSet): \"\"\" A viewset that provides `retrieve`, `create`, and `list` actions. To use it, override the class and set the `.queryset` and `.serializer_class` attributes. \"\"\" pass 通过创建自己的基ViewSet类，您可以提供可以在您的API的多个视图集中重用的常见行为。","categories":[{"name":"Django","slug":"Django","permalink":"http://xuqilong.com/categories/Django/"},{"name":"Django-Rest-framework","slug":"Django/Django-Rest-framework","permalink":"http://xuqilong.com/categories/Django/Django-Rest-framework/"}],"tags":[{"name":"restful","slug":"restful","permalink":"http://xuqilong.com/tags/restful/"},{"name":"Views","slug":"Views","permalink":"http://xuqilong.com/tags/Views/"},{"name":"Django","slug":"Django","permalink":"http://xuqilong.com/tags/Django/"},{"name":"Django-Rest-framework","slug":"Django-Rest-framework","permalink":"http://xuqilong.com/tags/Django-Rest-framework/"}]},{"title":"Django REST framework:Generic Views","slug":"generic-views","date":"2020-01-14T16:37:44.982Z","updated":"2020-01-14T16:55:30.832Z","comments":true,"path":"2020-01-15-generic-views.html","link":"","permalink":"http://xuqilong.com/2020-01-15-generic-views.html","excerpt":"Django的通用视图…是作为通用用法模式的快捷方式而开发的…它们采用视图开发中发现的某些通用习语和模式并将其抽象化，以便您可以快速编写通用数据视图而无需重复自己。","text":"Django的通用视图…是作为通用用法模式的快捷方式而开发的…它们采用视图开发中发现的某些通用习语和模式并将其抽象化，以便您可以快速编写通用数据视图而无需重复自己。 通用视图 Django的通用视图…是作为通用用法模式的快捷方式而开发的…它们采用视图开发中发现的某些通用习语和模式并将其抽象化，以便您可以快速编写通用数据视图而无需重复自己。 — Django文档 基于类的视图的主要优点之一是它们允许您组成一些可重用行为的方式。REST框架通过提供许多提供常用模式的预构建视图来利用此优势。 REST框架提供的通用视图使您可以快速构建与数据库模型紧密映射的API视图。 如果通用视图不符合您的API的需求，则可APIView以下拉到使用常规类，或者重用通用视图使用的mixins和基类来组成自己的可重用通用视图集。 例子通常，在使用通用视图时，您将覆盖视图并设置几个类属性。 123456789from django.contrib.auth.models import Userfrom myapp.serializers import UserSerializerfrom rest_framework import genericsfrom rest_framework.permissions import IsAdminUserclass UserList(generics.ListCreateAPIView): queryset = User.objects.all() serializer_class = UserSerializer permission_classes = [IsAdminUser] 对于更复杂的情况，您可能还想覆盖视图类上的各种方法。例如。 12345678910class UserList(generics.ListCreateAPIView): queryset = User.objects.all() serializer_class = UserSerializer permission_classes = [IsAdminUser] def list(self, request): # Note the use of `get_queryset()` instead of `self.queryset` queryset = self.get_queryset() serializer = UserSerializer(queryset, many=True) return Response(serializer.data) 对于非常简单的情况，您可能希望使用.as_view()方法传递任何类属性。例如，您的URLconf可能包含类似以下条目的内容： 1url(r'^/users/', ListCreateAPIView.as_view(queryset=User.objects.all(), serializer_class=UserSerializer), name='user-list') API参考GenericAPIView该类扩展了REST框架的APIView类，为标准列表和详细信息视图添加了通常需要的行为。 提供的每个具体的通用视图都是通过将GenericAPIView，和一个或多个mixin类组合而构建的。 属性基本设定： 以下属性控制基本视图行为。 queryset-应该用于从该视图返回对象的查询集。通常，您必须设置此属性或重写get_queryset()方法。如果要覆盖视图方法，则必须进行调用get_queryset()而不是直接访问此属性，这queryset将被评估一次，并且这些结果将被缓存用于所有后续请求，这一点很重要。 serializer_class-应该用于验证和反序列化输入以及序列化输出的序列化器类。通常，您必须设置此属性或重写get_serializer_class()方法。 lookup_field-应该用于执行单个模型实例的对象查找的模型字段。默认为&#39;pk&#39;。需要注意的是使用超链接的API时，您需要确保双方的API意见和串行类设置查找字段，如果你需要使用一个自定义值。 lookup_url_kwarg-用于对象查找的URL关键字参数。URL conf应包含与此值相对应的关键字参数。如果未设置，则默认使用与相同的值lookup_field。 分页： 与列表视图一起使用时，以下属性用于控制分页。 pagination_class-对列表进行分页时应使用的分页类。默认值为与DEFAULT_PAGINATION_CLASS设置相同的值&#39;rest_framework.pagination.PageNumberPagination&#39;。设置pagination_class=None将禁用此视图上的分页。 筛选： filter_backends-应该用于过滤查询集的过滤器后端类的列表。默认值为与DEFAULT_FILTER_BACKENDS设置相同的值。 方法基本方法： get_queryset(self)返回应用于列表视图的查询集，该查询集应用作详细视图中的查询的基础。默认情况下返回queryset属性指定的查询集。 应始终使用此方法，而不是self.queryset直接访问此方法，因为它self.queryset只会被评估一次，并且那些结果将为所有后续请求缓存。 可以重写以提供动态行为，例如返回特定于发出请求的用户的查询集。 例如： 123def get_queryset(self): user = self.request.user return user.accounts.all() get_object(self)返回应用于详细信息视图的对象实例。默认为使用lookup_field参数过滤基本查询集。 可以重写以提供更复杂的行为，例如基于多个URL kwarg的对象查找。 例如： 123456789def get_object(self): queryset = self.get_queryset() filter = &#123;&#125; for field in self.multiple_lookup_fields: filter[field] = self.kwargs[field] obj = get_object_or_404(queryset, **filter) self.check_object_permissions(self.request, obj) return obj 请注意，如果您的API不包含任何对象级别的权限，则可以选择排除self.check_object_permissions，而只需从get_object_or_404查找中返回对象即可。 filter_queryset(self, queryset)给定一个查询集，请使用正在使用的任何过滤器后端对其进行过滤，并返回一个新的查询集。 例如： 123456789101112def filter_queryset(self, queryset): filter_backends = [CategoryFilter] if 'geo_route' in self.request.query_params: filter_backends = [GeoRouteFilter, CategoryFilter] elif 'geo_point' in self.request.query_params: filter_backends = [GeoPointFilter, CategoryFilter] for backend in list(filter_backends): queryset = backend().filter_queryset(self.request, queryset, view=self) return queryset get_serializer_class(self)返回应用于序列化程序的类。默认为返回serializer_class属性。 可以重写以提供动态行为，例如使用不同的序列化程序进行读写操作，或为不同类型的用户提供不同的序列化程序。 例如： 1234def get_serializer_class(self): if self.request.user.is_staff: return FullAccountSerializer return BasicAccountSerializer 保存和删除钩子(hooks)： mixin类提供了以下方法，它们提供了覆盖对象保存或删除行为的简便方法。 perform_create(self, serializer)- CreateModelMixin保存新对象实例时调用。 perform_update(self, serializer)- UpdateModelMixin保存现有对象实例时调用。 perform_destroy(self, instance)- DestroyModelMixin删除对象实例时调用。 这些挂钩对于设置请求中隐含但不属于请求数据的属性特别有用。例如，您可以基于请求用户或基于URL关键字参数在对象上设置属性。 12def perform_create(self, serializer): serializer.save(user=self.request.user) 这些覆盖点对于添加在保存对象之前或之后发生的行为（例如通过电子邮件发送确认或记录更新）也特别有用。 123def perform_update(self, serializer): instance = serializer.save() send_email_confirmation(user=self.request.user, modified=instance) 您还可以通过引发来使用这些挂钩提供其他验证ValidationError()。如果您需要在数据库保存时应用一些验证逻辑，这将很有用。例如： 12345def perform_create(self, serializer): queryset = SignupRequest.objects.filter(user=self.request.user) if queryset.exists(): raise ValidationError('You have already signed up') serializer.save(user=self.request.user) 注意：这些方法取代旧式的2.x版pre_save，post_save，pre_delete和post_delete方法，这将不再可用。 其他方法： 尽管使用编写自定义视图，但您可能需要调用以下方法，因此通常不需要重写以下方法GenericAPIView。 get_serializer_context(self)-返回包含应提供给序列化程序的任何其他上下文的字典。默认为包括&#39;request&#39;，&#39;view&#39;和&#39;format&#39;关键词。 get_serializer(self, instance=None, data=None, many=False, partial=False) -返回序列化器实例。 get_paginated_response(self, data)-返回分页样式Response对象。 paginate_queryset(self, queryset)-如果需要，对查询集进行分页，或者返回页面对象，或者None未为此视图配置分页。 filter_queryset(self, queryset) -给定查询集，请使用正在使用的任何过滤器后端对其进行过滤，并返回新的查询集。 Mixinsmixin类提供用于提供基本视图行为的操作。请注意，mixin类提供了操作方法，而不是直接定义处理程序方法（例如.get()和.post()）。这样可以更灵活地构成行为。 mixin类可以从导入rest_framework.mixins。 ListModelMixin提供一种.list(request, *args, **kwargs)方法，该方法实现列出查询集。 如果填充了查询集，则返回一个200 OK响应，并将查询集的序列化表示形式作为响应的主体。可以可选地对响应数据进行分页。 CreateModelMixin提供一种.create(request, *args, **kwargs)方法，该方法实现创建和保存新模型实例。 如果创建了对象，则返回一个201 Created响应，该对象的序列化表示作为响应的主体。如果表示形式包含名为的键url，则将Location使用该值填充响应的标头。 如果提供的用于创建对象的请求数据无效，400 Bad Request则将返回响应，并将错误详细信息作为响应的正文。 RetrieveModelMixin提供一种.retrieve(request, *args, **kwargs)方法，该方法实现在响应中返回现有模型实例。 如果可以检索到对象，则返回一个200 OK响应，该对象的序列化表示作为响应的主体。否则将返回404 Not Found。 UpdateModelMixin提供一种.update(request, *args, **kwargs)方法，该方法实现更新和保存现有模型实例。 还提供了一种.partial_update(request, *args, **kwargs)方法，该方法与该update方法类似，但是用于更新的所有字段都是可选的。这样可以支持HTTP PATCH请求。 如果对象被更新，它将返回一个200 OK响应，该对象的序列化表示作为响应的主体。 如果提供的用于更新对象的请求数据无效，400 Bad Request则将返回响应，并将错误详细信息作为响应的主体。 DestroyModelMixin提供一种.destroy(request, *args, **kwargs)方法，该方法实现删除现有模型实例。 如果删除对象，则返回204 No Content响应，否则将返回404 Not Found。 具体的视图类以下类是具体的通用视图。如果您使用的是通用视图，那么通常这就是您要使用的级别，除非需要大量的自定义行为。 可以从中导入视图类rest_framework.generics。 CreateAPIView用于仅创建端点。 提供post方法处理程序。 扩展：GenericAPIView，CreateModelMixin ListAPIView用于只读端点，表示模型实例的集合。 提供get方法处理程序。 扩展：GenericAPIView，ListModelMixin RetrieveAPIView用于只读端点，以表示单个模型实例。 提供get方法处理程序。 扩展：GenericAPIView，RetrieveModelMixin DestroyAPIView用于单个模型实例**的仅删除**端点。 提供delete方法处理程序。 扩展：GenericAPIView，DestroyModelMixin UpdateAPIView用于单个模型实例**的仅更新**端点。 提供put和patch方法处理程序。 扩展：GenericAPIView，UpdateModelMixin ListCreateAPIView用于读写端点，表示模型实例的集合。 提供get和post方法处理程序。 扩展：GenericAPIView，ListModelMixin，CreateModelMixin RetrieveUpdateAPIView用于读取或更新端点以表示单个模型实例。 提供get，put并且patch方法处理。 扩展：GenericAPIView，RetrieveModelMixin，UpdateModelMixin RetrieveDestroyAPIView用于读取或删除端点，以表示单个模型实例。 提供get和delete方法处理程序。 扩展：GenericAPIView，RetrieveModelMixin，DestroyModelMixin RetrieveUpdateDestroyAPIView用于读写删除端点，以表示单个模型实例。 提供get，put，patch和delete方法处理。 扩展：GenericAPIView，RetrieveModelMixin，UpdateModelMixin，DestroyModelMixin 自定义通用视图通常，您会想要使用现有的通用视图，但会使用一些稍微自定义的行为。如果发现自己在多个地方重用了一些自定义行为，则可能需要将行为重构为一个通用类，然后可以根据需要将其应用于任何视图或视图集。 创建自定义mixins例如，如果您需要基于URL conf中的多个字段查找对象，则可以创建如下的mixin类： 123456789101112131415class MultipleFieldLookupMixin(object): \"\"\" Apply this mixin to any view or viewset to get multiple field filtering based on a `lookup_fields` attribute, instead of the default single field filtering. \"\"\" def get_object(self): queryset = self.get_queryset() # Get the base queryset queryset = self.filter_queryset(queryset) # Apply any filter backends filter = &#123;&#125; for field in self.lookup_fields: if self.kwargs[field]: # Ignore empty fields. filter[field] = self.kwargs[field] obj = get_object_or_404(queryset, **filter) # Lookup the object self.check_object_permissions(self.request, obj) return obj 然后，您可以在需要应用自定义行为的任何时间简单地将此混入应用于视图或视图集。 1234class RetrieveUserView(MultipleFieldLookupMixin, generics.RetrieveAPIView): queryset = User.objects.all() serializer_class = UserSerializer lookup_fields = ['account', 'username'] 如果您需要使用自定义行为，则使用自定义混合是一个不错的选择。 创建自定义基类如果要在多个视图之间使用混合，则可以更进一步，并创建自己的基础视图集，然后将其用于整个项目。例如： 1234567class BaseRetrieveView(MultipleFieldLookupMixin, generics.RetrieveAPIView): passclass BaseRetrieveUpdateDestroyView(MultipleFieldLookupMixin, generics.RetrieveUpdateDestroyAPIView): pass 如果您有自定义行为，并且需要在整个项目中的大量视图中重复执行自定义行为，那么使用自定义基类是一个不错的选择。 PUT 为创建在3.0版之前PUT，取决于对象是否存在，REST框架混合将其视为更新或创建操作。 允许PUT作为创建操作是有问题的，因为它必须公开有关对象存在或不存在的信息。与简单地返回404响应相比，透明地允许重新创建先前删除的实例必然是更好的默认行为，这也不是显而易见的。 “ PUTas 404”和“ PUTas create” 这两种样式在不同情况下都可以有效，但是从3.0版开始，由于它更简单，更明显，我们现在将404行为用作默认行为。 如果需要通用的PUT即创建行为，则可能需要将此类之AllowPUTAsCreateMixin类的内容作为混合添加到视图中。 第三方包以下第三方软件包提供了其他通用视图实现。 Django Rest多种模型Django Rest Multiple Models提供了通用视图（和混合），用于通过单个API请求发送多个序列化的模型和/或查询集。","categories":[{"name":"Django","slug":"Django","permalink":"http://xuqilong.com/categories/Django/"},{"name":"Django-Rest-framework","slug":"Django/Django-Rest-framework","permalink":"http://xuqilong.com/categories/Django/Django-Rest-framework/"}],"tags":[{"name":"restful","slug":"restful","permalink":"http://xuqilong.com/tags/restful/"},{"name":"Views","slug":"Views","permalink":"http://xuqilong.com/tags/Views/"},{"name":"Django","slug":"Django","permalink":"http://xuqilong.com/tags/Django/"},{"name":"Django-Rest-framework","slug":"Django-Rest-framework","permalink":"http://xuqilong.com/tags/Django-Rest-framework/"}]},{"title":"Django REST framework:Views","slug":"Views","date":"2020-01-14T16:37:42.915Z","updated":"2020-01-14T16:54:49.623Z","comments":true,"path":"2020-01-15-Views.html","link":"","permalink":"http://xuqilong.com/2020-01-15-Views.html","excerpt":"Django的基于类的视图是对旧式视图的欢迎。","text":"Django的基于类的视图是对旧式视图的欢迎。 基于类的视图 Django的基于类的视图是对旧式视图的欢迎。 — Reinout van Rees REST框架提供了一个APIView类，该类继承了Django的View类。 APIView类与常规View类在以下方面有所不同： 传递给处理程序方法的请求将是REST框架的Request实例，而不是Django的HttpRequest实例。 处理程序方法可能返回REST框架的Response而不是Django的HttpResponse。该视图将管理内容协商并在响应上设置正确的渲染器。 任何APIException异常都将被捕获并调解为适当的响应。 在将请求分派到处理程序方法之前，将对传入的请求进行身份验证并进行适当的权限和/或限制检查。 使用APIView该类与使用常规View类几乎相同，通常，传入的请求将分派到适当的处理程序方法，例如.get()或.post()。另外，可以在控制API策略各个方面的类上设置许多属性。 例如： 123456789101112131415161718192021from rest_framework.views import APIViewfrom rest_framework.response import Responsefrom rest_framework import authentication, permissionsfrom django.contrib.auth.models import Userclass ListUsers(APIView): \"\"\" View to list all users in the system. * Requires token authentication. * Only admin users are able to access this view. \"\"\" authentication_classes = [authentication.TokenAuthentication] permission_classes = [permissions.IsAdminUser] def get(self, request, format=None): \"\"\" Return a list of all users. \"\"\" usernames = [user.username for user in User.objects.all()] return Response(usernames) 注：完整的方法，属性，并与Django的REST框架的关系APIView，GenericAPIView各种Mixins，并且Viewsets可以初步复杂。除了此处的文档外，Classy Django REST Framework资源还为每个Django REST Framework基于类的视图提供了可浏览的参考，以及完整的方法和属性。 API策略属性以下属性控制API视图的可插入方面。 .renderer_classes.parser_classes.authentication_classes.throttle_classes.permission_classes.content_negotiation_classAPI策略实例化方法REST框架使用以下方法来实例化各种可插拔API策略。您通常不需要重写这些方法。 .get_renderers(self).get_parsers(self).get_authenticators(self).get_throttles(self).get_permissions(self).get_content_negotiator(self).get_exception_handler(self)API策略实施方法在分派到处理程序方法之前，将调用以下方法。 .check_permissions(self, request).check_throttles(self, request).perform_content_negotiation(self, request, force=False)Dispatch 方法视图的.dispatch()方法直接调用以下方法。这些执行需要之前或调用处理方法，如之后发生的任何动作.get()，.post()，put()，patch()和.delete()。 .initial(self, request, args, *kwargs)执行在调用处理程序方法之前需要执行的所有操作。此方法用于强制执行权限和限制，并执行内容协商。 您通常不需要重写此方法。 .handle_exception(self, exc)处理程序方法引发的任何异常都将传递给此方法，该方法将返回一个Response实例，或重新引发该异常。 默认实现处理的任何子类rest_framework.exceptions.APIException以及Django的Http404和PermissionDenied异常，并返回适当的错误响应。 如果您需要自定义错误响应，那么您的API返回的值应该子类化此方法。 .initialize_request(self, request, args, *kwargs)确保传递给处理程序方法的请求对象是的实例Request，而不是通常的Django HttpRequest。 您通常不需要重写此方法。 .finalize_response(self, request, response, args, *kwargs)确保Response从处理程序方法返回的任何对象都将呈现为正确的内容类型，这由内容协商确定。 您通常不需要重写此方法。 基于函数的视图 说[基于类的视图]始终是最佳解决方案，这是一个错误。 — 尼克·科格兰 REST框架还允许您使用基于常规函数的视图。它提供了一组简单的装饰器，包装了基于函数的视图，以确保它们接收的实例Request（而不是通常的Django HttpRequest），并允许它们返回Response（而不是Django HttpResponse），并允许您配置如何处理请求。 @api_view（）签名： @api_view(http_method_names=[&#39;GET&#39;]) 该功能的核心是api_view装饰器，该装饰器列出了视图应响应的HTTP方法的列表。例如，这是您编写一个非常简单的视图的方式，只需手动返回一些数据即可： 12345from rest_framework.decorators import api_view@api_view()def hello_world(request): return Response(&#123;\"message\": \"Hello, world!\"&#125;) 该视图将使用设置中指定的默认渲染器，解析器，身份验证类等。 默认情况下，只GET接受方法。其他方法将响应“ 405方法不允许”。要更改此行为，请指定视图允许的方法，如下所示： 12345@api_view(['GET', 'POST'])def hello_world(request): if request.method == 'POST': return Response(&#123;\"message\": \"Got some data!\", \"data\": request.data&#125;) return Response(&#123;\"message\": \"Hello, world!\"&#125;) API策略装饰器要覆盖默认设置，REST框架提供了一组其他装饰器，可以将其添加到视图中。这些必须在装饰器@api_view之后（下方）进行。例如，要创建使用throttle 来确保特定用户每天只能调用一次的视图，请使用@throttle_classes装饰器，并传递油门类列表： 12345678910from rest_framework.decorators import api_view, throttle_classesfrom rest_framework.throttling import UserRateThrottleclass OncePerDayUserThrottle(UserRateThrottle): rate = '1/day'@api_view(['GET'])@throttle_classes([OncePerDayUserThrottle])def view(request): return Response(&#123;\"message\": \"Hello for today! See you tomorrow!\"&#125;) 这些装饰器对应于APIView如上所述在子类上设置的属性。 可用的装饰器是： @renderer_classes(...) @parser_classes(...) @authentication_classes(...) @throttle_classes(...) @permission_classes(...) 这些装饰器中的每一个都带有一个参数，该参数必须是类的列表或元组。 视图架构装饰器要覆盖基于函数的视图的默认架构生成，可以使用@schema装饰器。这必须在装饰器@api_view之后（下方）进行。例如： 1234567891011from rest_framework.decorators import api_view, schemafrom rest_framework.schemas import AutoSchemaclass CustomAutoSchema(AutoSchema): def get_link(self, path, method, base_url): # override view introspection here...@api_view(['GET'])@schema(CustomAutoSchema())def view(request): return Response(&#123;\"message\": \"Hello for today! See you tomorrow!\"&#125;) 该装饰器采用一个AutoSchema实例，一个AutoSchema子类实例或Schemas文档ManualSchema中所述的实例。您可以通过以将视图从架构生成中排除。None 1234@api_view(['GET'])@schema(None)def view(request): return Response(&#123;\"message\": \"Will not appear in schema!\"&#125;)","categories":[{"name":"Django","slug":"Django","permalink":"http://xuqilong.com/categories/Django/"},{"name":"Django-Rest-framework","slug":"Django/Django-Rest-framework","permalink":"http://xuqilong.com/categories/Django/Django-Rest-framework/"}],"tags":[{"name":"restful","slug":"restful","permalink":"http://xuqilong.com/tags/restful/"},{"name":"Views","slug":"Views","permalink":"http://xuqilong.com/tags/Views/"},{"name":"Django","slug":"Django","permalink":"http://xuqilong.com/tags/Django/"},{"name":"Django-Rest-framework","slug":"Django-Rest-framework","permalink":"http://xuqilong.com/tags/Django-Rest-framework/"}]},{"title":"Django REST framework:Responses","slug":"Responses","date":"2020-01-14T16:37:35.890Z","updated":"2020-01-14T16:54:19.655Z","comments":true,"path":"2020-01-15-Responses.html","link":"","permalink":"http://xuqilong.com/2020-01-15-Responses.html","excerpt":"与基本的HttpResponse对象不同，TemplateResponse对象保留视图提供的上下文详细信息以计算响应。直到需要时才在响应过程的后面计算响应的最终输出。","text":"与基本的HttpResponse对象不同，TemplateResponse对象保留视图提供的上下文详细信息以计算响应。直到需要时才在响应过程的后面计算响应的最终输出。 Responses 与基本的HttpResponse对象不同，TemplateResponse对象保留视图提供的上下文详细信息以计算响应。直到需要时才在响应过程的后面计算响应的最终输出。 — Django文档 REST框架通过提供一个Response类来支持HTTP内容协商，该类允许您根据客户端请求返回可以呈现为多种内容类型的内容。 在Response类的子类Django的SimpleTemplateResponse。 Response对象使用数据初始化，该数据应包含本地Python原语。然后，REST框架使用标准的HTTP内容协商来确定应如何呈现最终响应内容。 不需要使用Response该类，也可以根据需要从视图中返回常规HttpResponse或StreamingHttpResponse对象。使用Response该类只是为返回内容协商的Web API响应提供了一个更好的接口，该响应可以呈现为多种格式。 除非出于某种原因要大量定制REST框架，否则应始终对返回对象的视图使用APIView类或@api_view函数Response。这样做可确保在视图返回视图之前，视图可以执行内容协商并为响应选择适当的渲染器。 建立回应Response()签名： Response(data, status=None, template_name=None, headers=None, content_type=None) 与常规HttpResponse对象不同，您不会实例化Response具有渲染内容的对象。相反，您传递未渲染的数据，该数据可能包含任何Python原语。 Response该类使用的渲染器无法本地处理诸如Django模型实例之类的复杂数据类型，因此您需要在创建Response对象之前将数据序列化为原始数据类型。 您可以使用REST框架的Serializer类来执行此数据序列化，也可以使用自己的自定义序列化。 参数： data：响应的序列化数据。 status：响应的状态码。默认值为200。另请参见状态码。 template_name：HTMLRenderer选择了要使用的模板名称。 headers：在响应中使用的HTTP标头字典。 content_type：响应的内容类型。通常，这将由呈现器根据内容协商确定自动设置，但是在某些情况下，您需要显式指定内容类型。 属性.data响应的未呈现的序列化数据。 .status_codeHTTP响应的数字状态码。 .content响应的呈现内容。必须先调用.render()方法，然后.content才能访问该方法。 .template_name的template_name，如果提供。仅当HTMLRenderer或其他自定义模板渲染器是响应的可接受渲染器时才需要。 .accepted_renderer将用于呈现响应的呈现器实例。 由APIView或@api_view在视图返回响应之前自动设置。 .accepted_media_type内容协商阶段选择的媒体类型。 由APIView或@api_view在视图返回响应之前自动设置。 .renderer_context附加上下文信息的词典，该词典将传递给渲染器的.render()方法。 由APIView或@api_view在视图返回响应之前自动设置。 标准HttpResponse属性在Response类扩展SimpleTemplateResponse，和所有常见的属性和方法也可在回应。例如，您可以以标准方式在响应上设置标头： 12response = Response()response['Cache-Control'] = 'no-cache' .render（）签名： .render() 与任何其他TemplateResponse方法一样，调用此方法可将响应的序列化数据呈现为最终响应内容。当.render()被调用时，响应内容将被设置为调用的结果.render(data, accepted_media_type, renderer_context)对方法accepted_renderer实例。 通常，您不需要自称.render()，因为它是Django的标准响应周期所处理的。","categories":[{"name":"Django","slug":"Django","permalink":"http://xuqilong.com/categories/Django/"},{"name":"Django-Rest-framework","slug":"Django/Django-Rest-framework","permalink":"http://xuqilong.com/categories/Django/Django-Rest-framework/"}],"tags":[{"name":"restful","slug":"restful","permalink":"http://xuqilong.com/tags/restful/"},{"name":"Responses","slug":"Responses","permalink":"http://xuqilong.com/tags/Responses/"},{"name":"Django","slug":"Django","permalink":"http://xuqilong.com/tags/Django/"},{"name":"Django-Rest-framework","slug":"Django-Rest-framework","permalink":"http://xuqilong.com/tags/Django-Rest-framework/"}]},{"title":"Django REST framework:Request","slug":"requst","date":"2020-01-14T05:32:36.820Z","updated":"2020-01-14T16:53:31.153Z","comments":true,"path":"2020-01-14-requst.html","link":"","permalink":"http://xuqilong.com/2020-01-14-requst.html","excerpt":"REST框架的Request类扩展了标准HttpRequest，增加了对REST框架的灵活请求解析和请求身份验证的支持。","text":"REST框架的Request类扩展了标准HttpRequest，增加了对REST框架的灵活请求解析和请求身份验证的支持。 Requests 如果您正在做基于REST的Web服务…则应忽略request.POST。 — Django开发人员小组 Malcom Tredinnick REST框架的Request类扩展了标准HttpRequest，增加了对REST框架的灵活请求解析和请求身份验证的支持。 Request 解析REST框架的Request对象提供了灵活的请求解析，使您能够以与通常处理表单数据相同的方式来处理JSON数据或其他媒体类型的请求。 .datarequest.data返回请求正文的解析内容。这类似于标准request.POST和request.FILES属性，除了： 它包括所有已解析的内容，包括文件和非文件输入。 它支持解析除以外的HTTP方法的内容POST，这意味着您可以访问PUT和PATCH请求的内容。 它支持REST框架的灵活请求解析，而不仅仅是支持表单数据。例如，您可以以处理传入表单数据的相同方式处理传入JSON数据。 有关更多详细信息，请参见解析器文档。 .query_paramsrequest.query_params是的更正确命名的同义词request.GET。 为了使代码内部更清晰，我们建议使用request.query_params，而不是Django的standard request.GET。这样做将有助于使您的代码库更加正确和明显-任何HTTP方法类型都可以包括查询参数，而不仅仅是GET请求。 .parsers在APIView类或@api_view装饰将确保这个属性被自动设置为列表Parser实例的基础上，parser_classes对视图设置或基于该DEFAULT_PARSER_CLASSES设置。 您通常不需要访问此属性。 注意：如果客户端发送格式错误的内容，则访问request.data可能会引发ParseError。默认情况下，REST框架的APIView类或@api_view装饰器将捕获错误并返回400 Bad Request响应。 如果客户端发送的请求的内容类型无法解析，则将UnsupportedMediaType引发异常，默认情况下将捕获该异常并返回415 Unsupported Media Type响应。 内容协商该请求公开了一些属性，使您可以确定内容协商阶段的结果。这使您可以实现一些行为，例如为不同的媒体类型选择不同的序列化方案。 .accepted_renderer内容协商阶段选择的渲染器实例。 .accepted_media_type一个字符串，表示内容协商阶段接受的媒体类型。 认证方式REST框架提供了灵活的按请求身份验证，使您能够： 对API的不同部分使用不同的身份验证策略。 支持使用多种身份验证策略。 提供与传入请求关联的用户和令牌信息。 .userrequest.user通常会返回的实例django.contrib.auth.models.User，尽管其行为取决于所使用的身份验证策略。 如果请求未经身份验证，则默认值为request.user的实例django.contrib.auth.models.AnonymousUser。 有关更多详细信息，请参见身份验证文档。 .authrequest.auth返回任何其他身份验证上下文。的确切行为request.auth取决于所使用的身份验证策略，但通常可能是身份验证请求所依据的令牌的实例。 如果该请求是未认证的，或者如果没有附加上下文存在时，默认值request.auth是None。 有关更多详细信息，请参见身份验证文档。 .authenticators在APIView类或@api_view装饰将确保这个属性被自动设置为列表Authentication实例的基础上，authentication_classes对视图设置或基于该DEFAULT_AUTHENTICATORS设置。 您通常不需要访问此属性。 注意：WrappedAttributeError调用.user或.auth属性时，您可能会看到一个凸起。这些错误源自作为标准的身份验证器AttributeError，但是有必要将它们重新引发为其他异常类型，以防止外部属性访问抑制它们。Python不会识别出AttributeError源于身份验证器，而是会假设请求对象没有.user或.auth属性。身份验证器将需要固定。 浏览器增强REST框架支持的几个浏览器增强功能，例如基于浏览器的PUT，PATCH和DELETE形式。 .methodrequest.method返回请求的HTTP方法的大写字符串表示形式。 基于浏览器的PUT，PATCH而DELETE形式是透明的支持。 有关更多信息，请参阅浏览器增强功能文档。 .content_typerequest.content_type，返回代表HTTP请求主体的媒体类型的字符串对象，如果未提供媒体类型，则返回空字符串。 通常，您通常不需要直接访问请求的内容类型，因为您通常将依赖于REST框架的默认请求解析行为。 如果确实需要访问请求的内容类型，则应.content_type优先使用属性而不是using request.META.get(&#39;HTTP_CONTENT_TYPE&#39;)，因为它为基于浏览器的非格式内容提供了透明的支持。 有关更多信息，请参阅浏览器增强功能文档。 .streamrequest.stream 返回表示请求正文内容的流。 通常，您通常不需要直接访问请求的内容，因为您通常会依赖REST框架的默认请求解析行为。 标准HttpRequest属性随着REST框架对RequestDjango 的扩展HttpRequest，所有其他标准属性和方法也都可用。例如request.META和request.session字典可以正常使用。 请注意，由于实现原因，Request该类不继承自HttpRequest类，而是使用composition扩展了该类。","categories":[{"name":"Django","slug":"Django","permalink":"http://xuqilong.com/categories/Django/"},{"name":"Django-Rest-framework","slug":"Django/Django-Rest-framework","permalink":"http://xuqilong.com/categories/Django/Django-Rest-framework/"}],"tags":[{"name":"restful","slug":"restful","permalink":"http://xuqilong.com/tags/restful/"},{"name":"request","slug":"request","permalink":"http://xuqilong.com/tags/request/"},{"name":"Django","slug":"Django","permalink":"http://xuqilong.com/tags/Django/"},{"name":"Django-Rest-framework","slug":"Django-Rest-framework","permalink":"http://xuqilong.com/tags/Django-Rest-framework/"}]},{"title":"Ingress的使用","slug":"1","date":"2020-01-06T12:42:18.357Z","updated":"2020-01-14T16:48:26.193Z","comments":true,"path":"2020-01-06-1.html","link":"","permalink":"http://xuqilong.com/2020-01-06-1.html","excerpt":"","text":"ingress的基本使用nginx ingress官网 kubernetes ingress介绍 ingress相当于nginx代理服务，在定义 Ingress策略之前，需要先部署Ingress Controller，以实现为所有后端 Service 提供一个统一的入口。 一、使用官网例子1、创建ingressContr=oller1kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/mandatory.yaml mandatory.yaml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267apiVersion: v1kind: Namespacemetadata: name: ingress-nginx labels: app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginx---kind: ConfigMapapiVersion: v1metadata: name: nginx-configuration namespace: ingress-nginx labels: app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginx---kind: ConfigMapapiVersion: v1metadata: name: tcp-services namespace: ingress-nginx labels: app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginx---kind: ConfigMapapiVersion: v1metadata: name: udp-services namespace: ingress-nginx labels: app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginx---apiVersion: v1kind: ServiceAccountmetadata: name: nginx-ingress-serviceaccount namespace: ingress-nginx labels: app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginx---apiVersion: rbac.authorization.k8s.io/v1beta1kind: ClusterRolemetadata: name: nginx-ingress-clusterrole labels: app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginxrules: - apiGroups: - \"\" resources: - configmaps - endpoints - nodes - pods - secrets verbs: - list - watch - apiGroups: - \"\" resources: - nodes verbs: - get - apiGroups: - \"\" resources: - services verbs: - get - list - watch - apiGroups: - \"\" resources: - events verbs: - create - patch - apiGroups: - \"extensions\" - \"networking.k8s.io\" resources: - ingresses verbs: - get - list - watch - apiGroups: - \"extensions\" - \"networking.k8s.io\" resources: - ingresses/status verbs: - update---apiVersion: rbac.authorization.k8s.io/v1beta1kind: Rolemetadata: name: nginx-ingress-role namespace: ingress-nginx labels: app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginxrules: - apiGroups: - \"\" resources: - configmaps - pods - secrets - namespaces verbs: - get - apiGroups: - \"\" resources: - configmaps resourceNames: # Defaults to \"&lt;election-id&gt;-&lt;ingress-class&gt;\" # Here: \"&lt;ingress-controller-leader&gt;-&lt;nginx&gt;\" # This has to be adapted if you change either parameter # when launching the nginx-ingress-controller. - \"ingress-controller-leader-nginx\" verbs: - get - update - apiGroups: - \"\" resources: - configmaps verbs: - create - apiGroups: - \"\" resources: - endpoints verbs: - get---apiVersion: rbac.authorization.k8s.io/v1beta1kind: RoleBindingmetadata: name: nginx-ingress-role-nisa-binding namespace: ingress-nginx labels: app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginxroleRef: apiGroup: rbac.authorization.k8s.io kind: Role name: nginx-ingress-rolesubjects: - kind: ServiceAccount name: nginx-ingress-serviceaccount namespace: ingress-nginx---apiVersion: rbac.authorization.k8s.io/v1beta1kind: ClusterRoleBindingmetadata: name: nginx-ingress-clusterrole-nisa-binding labels: app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginxroleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: nginx-ingress-clusterrolesubjects: - kind: ServiceAccount name: nginx-ingress-serviceaccount namespace: ingress-nginx---apiVersion: apps/v1kind: Deploymentmetadata: name: nginx-ingress-controller namespace: ingress-nginx labels: app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginxspec: replicas: 1 selector: matchLabels: app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginx template: metadata: labels: app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginx annotations: prometheus.io/port: \"10254\" prometheus.io/scrape: \"true\" spec: serviceAccountName: nginx-ingress-serviceaccount containers: - name: nginx-ingress-controller image: quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.25.0 args: - /nginx-ingress-controller - --configmap=$(POD_NAMESPACE)/nginx-configuration - --tcp-services-configmap=$(POD_NAMESPACE)/tcp-services - --udp-services-configmap=$(POD_NAMESPACE)/udp-services - --publish-service=$(POD_NAMESPACE)/ingress-nginx - --annotations-prefix=nginx.ingress.kubernetes.io securityContext: allowPrivilegeEscalation: true capabilities: drop: - ALL add: - NET_BIND_SERVICE # www-data -&gt; 33 runAsUser: 33 env: - name: POD_NAME valueFrom: fieldRef: fieldPath: metadata.name - name: POD_NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace ports: - name: http containerPort: 80 - name: https containerPort: 443 livenessProbe: failureThreshold: 3 httpGet: path: /healthz port: 10254 scheme: HTTP initialDelaySeconds: 10 periodSeconds: 10 successThreshold: 1 timeoutSeconds: 10 readinessProbe: failureThreshold: 3 httpGet: path: /healthz port: 10254 scheme: HTTP periodSeconds: 10 successThreshold: 1 timeoutSeconds: 10--- 2、创建service1kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/provider/baremetal/service-nodeport.yaml service-nodeport.yaml 使用NodePort的方式 123456789101112131415161718192021222324apiVersion: v1kind: Servicemetadata: name: ingress-nginx namespace: ingress-nginx labels: app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginxspec: type: NodePort ports: - name: http port: 80 targetPort: 80 protocol: TCP - name: https port: 443 targetPort: 443 protocol: TCP selector: app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginx--- 查看pod和service 123456789101112[root@k8s-master ~]# kubectl get all -n ingress-nginxNAME READY STATUS RESTARTS AGEpod/nginx-ingress-controller-86449c74bb-4npwg 1/1 Running 0 54sNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEservice/ingress-nginx NodePort 10.111.19.182 &lt;none&gt; 80:9861/TCP,443:59639/TCP 43sNAME READY UP-TO-DATE AVAILABLE AGEdeployment.apps/nginx-ingress-controller 1/1 1 1 54sNAME DESIRED CURRENT READY AGEreplicaset.apps/nginx-ingress-controller-86449c74bb 1 1 1 54s 提示：service 没有特地绑定node端口，通过service可知nodeport为9861，后面的http访问都要使用这个端口 通过浏览器访问节点ip:9861返回404则证明创建成功 3、创建backend我们需要一个后端服务，通过ingress转发后端服务 myweb-tomcat.yaml service使用ClusterIP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: myweb namespace: ingress-nginx labels: app: myweb version: v1.1.1spec: replicas: 1 selector: matchLabels: app: myweb template: metadata: labels: app: myweb spec: containers: - image: tomcat:8.0 name: myweb ports: - containerPort: 8080 protocol: TCP args: # Uncomment the following line to manually specify Kubernetes API server Host # If not specified, Dashboard will attempt to auto discover the API server and connect livenessProbe: httpGet: path: / port: 8080 initialDelaySeconds: 30 timeoutSeconds: 30---apiVersion: v1kind: Servicemetadata: name: myweb labels: app: mywebspec: #默认为type: ClusterIP selector: app: myweb ports: - port: 80 targetPort: 8080 4、创建对应的ingress通过该ingress转发刚刚创建的backend 提示：``kubernetes官网中apiVersion使用的是networking.k8s.io/v1beta1，ingress官网使用extensions/v1beta1` tomcat-ingress.yaml 123456789101112131415apiVersion: networking.k8s.io/v1beta1kind: Ingressmetadata: name: tomcat-ingress namespace: ingress-nginx annotations: kubernetes.io/ingress.class: \"nginx\"spec: rules: - host: tomcat.test.com http: paths: - backend: serviceName: myweb servicePort: 80 查看创建是否成功 12345678910[root@k8s-master mytest]# kubectl get ing -n ingress-nginxNAME HOSTS ADDRESS PORTS AGEtomcat-ingress tomcat.test.com 80 23s[root@k8s-master mytest]# kubectl get pod -n ingress-nginxNAME READY STATUS RESTARTS AGEmyweb-55c44c498d-95pvw 1/1 Running 0 17snginx-ingress-controller-86449c74bb-4npwg 1/1 Running 0 20m[root@k8s-master mytest]# kubectl get svcNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEkubernetes ClusterIP 10.96.0.1 &lt;none&gt; 443/TCP 22d 5、测试 因为绑定的域名为tomcat.test.com，所以需要现在/etc/hosts绑定域名 123127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6172.25.21.66 k8s-master tomcat.test.com 访问测试 1234567[root@k8s-master mytest]# curl -I tomcat.test.com:9861HTTP/1.1 200 OKServer: openresty/1.15.8.1Date: Thu, 08 Aug 2019 06:23:16 GMTContent-Type: text/html;charset=UTF-8Connection: keep-aliveVary: Accept-Encoding 返回预期内容，创建成功 局域网访问 win中添加DNS 在该文件C:\\Windows\\System32\\drivers\\etc\\hosts最后一行中添加172.25.21.66 tomcat.test.com 现在就可以通过浏览器使用域名tomcat.test.com访问了 6、问题但是有个问题，通过node节点IP不能成功，myweb的集群IP可以访问 1234567891011121314[root@k8s-master mytest]# curl -I 172.25.21.66:9861HTTP/1.1 404 Not FoundServer: openresty/1.15.8.1Date: Thu, 08 Aug 2019 06:24:27 GMTContent-Type: text/htmlContent-Length: 159Connection: keep-alive[root@k8s-master mytest]# curl -I 10.99.77.4HTTP/1.1 200 OKServer: Apache-Coyote/1.1Content-Type: text/html;charset=UTF-8Transfer-Encoding: chunkedDate: Thu, 08 Aug 2019 06:26:25 GMT 7、解决方法直接使用http，没有host apiVersion使用networking.k8s.io/v1beta1 1234567891011121314151617apiVersion: networking.k8s.io/v1beta1kind: Ingressmetadata: name: name-virtual-host-ingressspec: rules: - host: tomcat.test.com http: paths: - backend: serviceName: myweb servicePort: 80 - http: paths: - backend: serviceName: myweb servicePort: 80 测试： 1234567891011121314151617[root@k8s-master tomcat]# curl -I 172.25.21.66HTTP/1.1 308 Permanent RedirectServer: openresty/1.15.8.1Date: Thu, 08 Aug 2019 08:28:08 GMTContent-Type: text/htmlContent-Length: 177Connection: keep-aliveLocation: https://172.25.21.66/[root@k8s-master tomcat]# curl -Ik https://172.25.21.66 #使用https访问HTTP/1.1 200 OKServer: openresty/1.15.8.1Date: Thu, 08 Aug 2019 08:37:24 GMTContent-Type: text/html;charset=UTF-8Connection: keep-aliveVary: Accept-EncodingStrict-Transport-Security: max-age=15724800; includeSubDomains 注意：使用无域名的Ingress转发规则时，将默认禁用非安全HTTP,强制启用HTTPS. 可以在Ingress的定义中设置一个 annotation: nginx.ingress.kubernetes.io/ssl-redirect=&quot;false&quot;&quot; 来关闭强制启用HTTPS的设置。 例如： 12345678910111213141516171819apiVersion: networking.k8s.io/v1beta1kind: Ingressmetadata: name: name-virtual-host-ingress annotations: nginx.ingress.kubernetes.io/ssl-redirect: \"false\"spec: rules: - host: tomcat.test.com http: paths: - backend: serviceName: myweb servicePort: 80 - http: paths: - backend: serviceName: myweb servicePort: 80 二、修改后方式因为官网例子没有使用node节点的80和443端口，所以我们需要自己修改 提示：kubelet默认开发的端口是没有80的，需要修改配置 123456vim /etc/kubernetes/manifests/kube-apiserver.yaml - --service-account-key-file=/etc/kubernetes/pki/sa.pub - --service-cluster-ip-range=10.96.0.0/12 - --service-node-port-range=1-65535 #添加该选项开放使用端口，然后重启kubelet - --tls-cert-file=/etc/kubernetes/pki/apiserver.crt ingressController的修改，主要修改Deployment，Deployment可以改为DaemonSet。这里就贴出Deployment部分内容，其他和上面一样 1、改为hostPort提示：这里不需要创建ingressController的service mandatory.yaml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778apiVersion: apps/v1kind: Deploymentmetadata: name: nginx-ingress-controller namespace: ingress-nginx labels: app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginxspec: replicas: 1 selector: matchLabels: app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginx template: metadata: labels: app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginx annotations: prometheus.io/port: \"10254\" prometheus.io/scrape: \"true\" spec: serviceAccountName: nginx-ingress-serviceaccount containers: - name: nginx-ingress-controller image: quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.25.0 args: - /nginx-ingress-controller - --configmap=$(POD_NAMESPACE)/nginx-configuration - --tcp-services-configmap=$(POD_NAMESPACE)/tcp-services - --udp-services-configmap=$(POD_NAMESPACE)/udp-services - --publish-service=$(POD_NAMESPACE)/ingress-nginx - --annotations-prefix=nginx.ingress.kubernetes.io securityContext: allowPrivilegeEscalation: true capabilities: drop: - ALL add: - NET_BIND_SERVICE # www-data -&gt; 33 runAsUser: 33 env: - name: POD_NAME valueFrom: fieldRef: fieldPath: metadata.name - name: POD_NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace ports: - name: http containerPort: 80 hostPort: 80 #修改为hostPort - name: https containerPort: 443 hostPort: 443 #修改为hostPort livenessProbe: failureThreshold: 3 httpGet: path: /healthz port: 10254 scheme: HTTP initialDelaySeconds: 10 periodSeconds: 10 successThreshold: 1 timeoutSeconds: 10 readinessProbe: failureThreshold: 3 httpGet: path: /healthz port: 10254 scheme: HTTP periodSeconds: 10 successThreshold: 1 timeoutSeconds: 10 测试成功 1234567[root@k8s-master ingree-controller]# curl -I tomcat.test.comHTTP/1.1 200 OKServer: openresty/1.15.8.1Date: Thu, 08 Aug 2019 06:44:05 GMTContent-Type: text/html;charset=UTF-8Connection: keep-aliveVary: Accept-Encoding 需要说明的是，客户端只能通过域名 tomcat.test.com访问服务，这时要求客户端或者 DNS 能够将 tomcat.test.com域名解析到后端多个Node 的真实 IP 地址上。 通过 curl 访问 tomcat.test.com 提供的服务（可以用 –resolve 参数模拟 DNS 解析，目标地址为域名；也可以用-H &#39;HOST:tomcat.test.com&#39;参数设置 HTTP 投中要访问的域名，目标地址为 IP 地址），可以得到myweb返回的网页内容。 12curl --resolve tomcat.test.com:172.25.21.66 http://tomcat.test.com/#或者curl -H 'Host:tomcat.test.com' http://172.25.21.66/ 2、 改为hostNetwork提示：这里不需要创建ingressController的service mandatory.yaml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677apiVersion: apps/v1kind: Deploymentmetadata: name: nginx-ingress-controller namespace: ingress-nginx labels: app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginxspec: replicas: 1 selector: matchLabels: app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginx template: metadata: labels: app.kubernetes.io/name: ingress-nginx app.kubernetes.io/part-of: ingress-nginx annotations: prometheus.io/port: \"10254\" prometheus.io/scrape: \"true\" spec: hostNetwork: true #改为hostNetwork serviceAccountName: nginx-ingress-serviceaccount containers: - name: nginx-ingress-controller image: quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.25.0 args: - /nginx-ingress-controller - --configmap=$(POD_NAMESPACE)/nginx-configuration - --tcp-services-configmap=$(POD_NAMESPACE)/tcp-services - --udp-services-configmap=$(POD_NAMESPACE)/udp-services - --publish-service=$(POD_NAMESPACE)/ingress-nginx - --annotations-prefix=nginx.ingress.kubernetes.io securityContext: allowPrivilegeEscalation: true capabilities: drop: - ALL add: - NET_BIND_SERVICE # www-data -&gt; 33 runAsUser: 33 env: - name: POD_NAME valueFrom: fieldRef: fieldPath: metadata.name - name: POD_NAMESPACE valueFrom: fieldRef: fieldPath: metadata.namespace ports: - name: http containerPort: 80 - name: https containerPort: 443 livenessProbe: failureThreshold: 3 httpGet: path: /healthz port: 10254 scheme: HTTP initialDelaySeconds: 10 periodSeconds: 10 successThreshold: 1 timeoutSeconds: 10 readinessProbe: failureThreshold: 3 httpGet: path: /healthz port: 10254 scheme: HTTP periodSeconds: 10 successThreshold: 1 timeoutSeconds: 10 测试成功 1234567[root@k8s-master ingree-controller]# curl -I tomcat.test.comHTTP/1.1 200 OKServer: openresty/1.15.8.1Date: Thu, 08 Aug 2019 06:50:46 GMTContent-Type: text/html;charset=UTF-8Connection: keep-aliveVary: Accept-Encoding 三、ingress使用其他使用1、一个域名多个路径注意需要添加的annotations 12345678910111213141516171819apiVersion: networking.k8s.io/v1beta1kind: Ingressmetadata: name: simple-fanout-example annotations: nginx.ingress.kubernetes.io/rewrite-target: /spec: rules: - host: foo.bar.com http: paths: - path: /foo backend: serviceName: service1 servicePort: 4200 - path: /bar backend: serviceName: service2 servicePort: 8080 示例： myweb2-tomcat.yaml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: myweb2 namespace: ingress-nginx labels: app: myweb2spec: replicas: 1 selector: matchLabels: app: myweb2 template: metadata: labels: app: myweb2 spec: containers: - image: tomcat:8.0 name: myweb2 ports: - containerPort: 8080 protocol: TCP args: # Uncomment the following line to manually specify Kubernetes API server Host # If not specified, Dashboard will attempt to auto discover the API server and connect livenessProbe: httpGet: path: / port: 8080 initialDelaySeconds: 30 timeoutSeconds: 30---apiVersion: v1kind: Servicemetadata: name: myweb2 namespace: ingress-nginx labels: app: myweb2spec: #默认为type: ClusterIP selector: app: myweb2 ports: - port: 80 targetPort: 8080 tomcat-ingress.yaml 注意需要添加的annotations 12345678910111213141516171819202122232425262728293031apiVersion: networking.k8s.io/v1beta1kind: Ingressmetadata: name: tomcat-ingress namespace: ingress-nginx annotations: nginx.ingress.kubernetes.io/rewrite-target: /spec: rules: - host: tomcat.test.com http: paths: - path: /foo backend: serviceName: myweb servicePort: 80 - path: /bar backend: serviceName: myweb2 servicePort: 80 - http: paths: - backend: serviceName: myweb servicePort: 80 - http: paths: - path: /demo backend: serviceName: myweb servicePort: 80 测试： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152[root@k8s-master tomcat]# curl -Ik http://tomcat.test.com/fooHTTP/1.1 200 OKServer: openresty/1.15.8.1Date: Thu, 08 Aug 2019 09:06:55 GMTContent-Type: text/html;charset=UTF-8Connection: keep-aliveVary: Accept-Encoding[root@k8s-master tomcat]# curl -Ik http://tomcat.test.com/barHTTP/1.1 200 OKServer: openresty/1.15.8.1Date: Thu, 08 Aug 2019 09:07:00 GMTContent-Type: text/html;charset=UTF-8Connection: keep-aliveVary: Accept-Encoding[root@k8s-master tomcat]# curl -Ik https://tomcat.test.com/fooHTTP/1.1 404 Not FoundServer: openresty/1.15.8.1Date: Thu, 08 Aug 2019 09:07:04 GMTContent-Type: text/html;charset=utf-8Connection: keep-aliveVary: Accept-EncodingContent-Language: enStrict-Transport-Security: max-age=15724800; includeSubDomains[root@k8s-master tomcat]# curl -Ik https://172.25.21.66HTTP/1.1 200 OKServer: openresty/1.15.8.1Date: Thu, 08 Aug 2019 09:09:37 GMTContent-Type: text/html;charset=UTF-8Connection: keep-aliveVary: Accept-EncodingStrict-Transport-Security: max-age=15724800; includeSubDomains[root@k8s-master ingress]# curl -Ik https://172.25.21.66/demoHTTP/1.1 200 OKServer: openresty/1.15.8.1Date: Fri, 09 Aug 2019 01:45:44 GMTContent-Type: text/html;charset=UTF-8Connection: keep-aliveVary: Accept-EncodingStrict-Transport-Security: max-age=15724800; includeSubDomains[root@k8s-master ingress]# curl -Ik http://172.25.21.66/demoHTTP/1.1 200 OKServer: openresty/1.15.8.1Date: Fri, 09 Aug 2019 01:45:48 GMTContent-Type: text/html;charset=UTF-8Connection: keep-aliveVary: Accept-Encoding 这里有个问题：通过域名使用https访问会返回404错误，而通过IP使用https访问则不会有这种错误 原因：使用https访问相当于使用IP访问，访问https://tomcat.test.com/foo等于访问https://172.25.21.66/foo，因为IP访问的配置没有`/foo`，所有返回404。可以通过配置TLS安全设置以实现https访问域名的功能。 2、多个域名tomcat-ingress.yaml 123456789101112131415161718apiVersion: networking.k8s.io/v1beta1kind: Ingressmetadata: name: name-virtual-host-ingressspec: rules: - host: foo.bar.com http: paths: - backend: serviceName: service1 servicePort: 80 - host: bar.foo.com http: paths: - backend: serviceName: service2 servicePort: 80 tomcat-ingress.yaml 1234567891011121314151617181920212223apiVersion: networking.k8s.io/v1beta1kind: Ingressmetadata: name: name-virtual-host-ingressspec: rules: - host: first.bar.com http: paths: - backend: serviceName: service1 servicePort: 80 - host: second.foo.com http: paths: - backend: serviceName: service2 servicePort: 80 - http: paths: - backend: serviceName: service3 servicePort: 80 示例1 tomcat-ingress.yaml 123456789101112131415161718192021apiVersion: extensions/v1beta1kind: Ingressmetadata: name: tomcat-ingress namespace: ingress-nginx annotations: kubernetes.io/ingress.class: \"nginx\"spec: rules: - host: tomcat.test.com http: paths: - backend: serviceName: myweb servicePort: 80 - host: tomcat.nedy.com http: paths: - backend: serviceName: myweb2 servicePort: 80 测试 123456789101112131415[root@k8s-master tomcat]# curl -I tomcat.test.comHTTP/1.1 200 OKServer: openresty/1.15.8.1Date: Thu, 08 Aug 2019 08:18:51 GMTContent-Type: text/html;charset=UTF-8Connection: keep-aliveVary: Accept-Encoding[root@k8s-master tomcat]# curl -I tomcat.nedy.comHTTP/1.1 200 OKServer: openresty/1.15.8.1Date: Thu, 08 Aug 2019 08:19:11 GMTContent-Type: text/html;charset=UTF-8Connection: keep-aliveVary: Accept-Encoding 示例2 tomcat-ingress.yaml 123456789101112131415161718192021222324apiVersion: networking.k8s.io/v1beta1kind: Ingressmetadata: name: tomcat-ingress namespace: ingress-nginxspec: rules: - host: tomcat.test.com http: paths: - backend: serviceName: myweb servicePort: 80 - host: tomcat.nedy.com http: paths: - backend: serviceName: myweb2 servicePort: 80 - http: paths: - backend: serviceName: myweb3 servicePort: 80 测试： 123456789101112131415161718192021222324252627282930313233[root@k8s-master tomcat]# curl -I tomcat.nedy.com #可以使用https，这样相当于IP访问HTTP/1.1 200 OKServer: openresty/1.15.8.1Date: Thu, 08 Aug 2019 08:27:56 GMTContent-Type: text/html;charset=UTF-8Connection: keep-aliveVary: Accept-Encoding[root@k8s-master tomcat]# curl -I tomcat.test.com HTTP/1.1 200 OKServer: openresty/1.15.8.1Date: Thu, 08 Aug 2019 08:27:58 GMTContent-Type: text/html;charset=UTF-8Connection: keep-aliveVary: Accept-Encoding[root@k8s-master tomcat]# curl -I 172.25.21.66HTTP/1.1 308 Permanent RedirectServer: openresty/1.15.8.1Date: Thu, 08 Aug 2019 08:28:08 GMTContent-Type: text/htmlContent-Length: 177Connection: keep-aliveLocation: https://172.25.21.66/[root@k8s-master tomcat]# curl -Ik https://172.25.21.66 #可以使用https，和https://tomcat.nedy.com效果相同HTTP/1.1 200 OKServer: openresty/1.15.8.1Date: Thu, 08 Aug 2019 08:37:24 GMTContent-Type: text/html;charset=UTF-8Connection: keep-aliveVary: Accept-EncodingStrict-Transport-Security: max-age=15724800; includeSubDomains 四、Ingress的TLS安全设置对于使用https设置TLS的安全证书方面，Ingress 也可以支持。通过以下步骤进行设置： 创建自签名的密钥和SSL证书文件 将证书保存到Kubernetes中的一个Secret资源对象上。 将该Secret对象设置到Ingress中。 创建Secret secret.yaml 123456789apiVersion: v1kind: Secretmetadata: name: testsecret-tls namespace: defaultdata: tls.crt: base64 encoded cert # cert 文件内容 tls.key: base64 encoded key # key 文件内容type: kubernetes.io/tls 在Ingress中引用 Secret: secret-ingress.yaml 1234567891011121314151617apiVersion: networking.k8s.io/v1beta1kind: Ingressmetadata: name: tls-example-ingressspec: tls: - hosts: - sslexample.foo.com secretName: testsecret-tls rules: - host: sslexample.foo.com http: paths: - path: / backend: serviceName: service1 servicePort: 80 示例： 1、创建证书1openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout rsa_private.key -out cret.crt -subj \"/CN=tomcat.nedy.com/O=vihoo\" 如果提供服务的网站不止一个域名，例如前面的第 3 中Ingress策略配置方式，则 SSL证书需要使用额外的一个 x509 v3 配置文件辅助完成，在[alt_names] 段中完成多个DNS域名的设置： /etc/ssl/openssl.cnf 1`...``[alt_names]``DNS.1 = mywebsite.com``DNS.2 = mywebsite2.com` 然后使用 OpenSSl 工具完成秘钥和证书的创建。 1) 首先完成自签名 CA 证书： 1`$ openssl genrsa -out ca.key 2048``Generating RSA private key, 2048 bit long modulus``..........+++``................................................+++``e is 65537 (0x10001)`` ` `$ openssl req -x509 -new -nodes -key ca.key -days 5000 -out ca.crt -subj ``\"/CN=mywebsite.com\"` 2) 基于 openssl.cnf和ca 证书生成ingress SSL 证书： 1`$ openssl genrsa -out ingress.key 2048``Generating RSA private key, 2048 bit long modulus``.................................+++``..............................................................................................+++``e is 65537 (0x10001)`` ` `$ openssl req -new -key ingress.key -out ingress.csr -subj ``\"/CN=mywebsite.com\"` `-config ``/etc/ssl/openssl``.cnf`` ` `$ openssl x509 -req -``in` `ingress.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out ingress.crt -days 5000 -extensions v3_req -extfile ``/etc/ssl/openssl``.cnf``Signature ok``subject=``/CN``=mywebsite.com``Getting CA Private Key` 2、创建secretsecret.yaml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152apiVersion: v1kind: Secretmetadata: name: testsecret-tls namespace: ingress-nginxdata: tls.crt: | MIIDJzCCAg+gAwIBAgIJAOpo5VvpwbsbMA0GCSqGSIb3DQEBCwUAMCoxGDAWBgNV BAMMD3RvbWNhdC5uZWR5LmNvbTEOMAwGA1UECgwFdmlob28wHhcNMTkwODA4MTAx MTI3WhcNMjAwODA3MTAxMTI3WjAqMRgwFgYDVQQDDA90b21jYXQubmVkeS5jb20x DjAMBgNVBAoMBXZpaG9vMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA qJYVO48OujM/ScRAZXyuuNZocIhwsaq25xTCeyVfF41C3Mjjb3ATnIQQjkOKlfMs AduZoQjnliHjOdaQIBvSrl+SDKpnND3lrFtiJA+pvPB7A6IXXeOZ0FmNFy/VIk1X 2e1lDNQpBQdr/uVFLeNFpeqBizaZ5m6BnI3OXmeSOzxnEvhMyKAs4LMi4yDpuf+t VKaMrBmzdIGVsm0J+Pq+5igfLIodnJ6bYMaXrA1bx00LyvBfq8JX1Vi6tdL9u8L6 iiyUCsubHvxx9NrB+x7dIkCJ4ppG7Z2PyhihTHrgFhIupHmusYOubuVVHcr/BPdZ RDh6C5mQrERcVZeHrE2RBwIDAQABo1AwTjAdBgNVHQ4EFgQUmeqpqaCMVEFDQpSV d486Q2jtT8MwHwYDVR0jBBgwFoAUmeqpqaCMVEFDQpSVd486Q2jtT8MwDAYDVR0T BAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAQEAlbLlvRimWAmPORZ0q7u1YUIygBBs AZeXXhNPjiWoU5o8lG/Ic8OfnQp++rnfyW+YNehoapLcOgIdS9yMZnegi6s+RW4H 0OAlGg5WC+/gwsVMWuzziAf4YJQBQCKtA6UbZTG/kk/9kDue9yMD6Fx4t68KGO05 rvt6TZIFlgrzwPSa8jHgboZonlV7/62fRRaGDGLOnv/ip6eBup4Gl3L5UTm8VZqf UGADwwXXXE/p5Zeox16bNkPDQAp5AoeMpTZ6tZQmRsx4/L3xX2qLtj4u7Xrdp8vF uA6TFeKpdjag9mljZu798iHjedUF5T8QK20/3mPgSiz6mLNACqxAqKaoBw== tls.key: | MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQColhU7jw66Mz9J xEBlfK641mhwiHCxqrbnFMJ7JV8XjULcyONvcBOchBCOQ4qV8ywB25mhCOeWIeM5 1pAgG9KuX5IMqmc0PeWsW2IkD6m88HsDohdd45nQWY0XL9UiTVfZ7WUM1CkFB2v+ 5UUt40Wl6oGLNpnmboGcjc5eZ5I7PGcS+EzIoCzgsyLjIOm5/61UpoysGbN0gZWy bQn4+r7mKB8sih2cnptgxpesDVvHTQvK8F+rwlfVWLq10v27wvqKLJQKy5se/HH0 2sH7Ht0iQInimkbtnY/KGKFMeuAWEi6kea6xg65u5VUdyv8E91lEOHoLmZCsRFxV l4esTZEHAgMBAAECggEASvD0nVY5uMIBNzx7V+H2FYqSQLwWRJRb3BtZXL6/J8wO 1fCjUa1jumbmqScTGxdPD8Bb6b74m7+Sr+pWhT95BzTKysCRQiLlzxmMZfVkge3w 8SuD8aO0g27bjlwgBbCWBfVGv04sseSbuGKYvw5RrrCxR35NKackDMDo5QRrd9Lo VBe//2OW2piAUq56Ln3mU4+F6+NFhjbwxpc2tCqI8HMqqb1Pg5dE2FGw801OCyoX 38gPqKutaJA3eGzw1S0Re866FBf/FYyjmV1oPNW0wrBP2/SqBIVWDLDNINeK3JnF 3LyB7rj7Ve0zeSM44moIloPvgzq1Yj0TE94jIFBAwQKBgQDSYt3zATv7QXX/MUtq 1tGPii3ZgPCYvCyY2vrxOktgDsIYA426u8HqDbMXKR0kED/mMP7OfJaISt6wYZBB 8sN7vSb1ewq6a4s7wfI6XE3jDgx+b8MwNnPS5be66L8QHNcsHkONbDthFbt0X6I6 qxYQAkXthfJ/iAdn+6YYP/YaoQKBgQDNIy43zBZhWlon4DTLg0ilk6hgHcjcxjG5 cD02Ucy4FdBPJ7iC0i4w4Ca+aL//ruVC1DZyYN57XYq1o/LvFZSBGq6gUhDm6KSU tMILgbIcVkq2CuiKX0K90IVDaji3rOqIJeZIZf1NWV6o3IohQyOl0Wvx7Qh3+Ijv dROMK9bypwKBgCYNt/OST5UcvAkSk3+Zp4H9Dln/FoWp0686PJWRY7zWLolFa0dR WrvJCpGv4BN71PL//ba/lkLEuA7TNtKW5IDnL7rLLJ+XgDGo3PVtaLEfA2eDM5zu 3HhTEK6AFr8FWG4kczeLUho3YhakjaVq+KygnKFfzwL+ScinHd3ZA9zBAoGAJfo+ YzwYZJual0lN3OOIPocwo+K/vge/Sup5mqXYNbhsIUtkQGvy+z90TMoNyaMydIXf Mpu2dLZjqK8amaKwJJqw+6NV17n4RkOUrRasx8w99qfcV0m9jHCfS1TN/Us4/E2v 7XVcSMaj3LU/qVrJrbgwuNA+Qh+0EkjlfozbNX8CgYEAmFyHG68VMoqF0Hn0I0as YqHaIJywR/1lNB2eZ5zYrloofkI7uUDOZuB2Ba2TS7ToAIRcJ/0/XoW8hBqh/k7o b9s/DjA6oIW6MlCTscjy6abJx2cEoJ5G3yoBQJBwAWgw/chn6LqzkcSRUQ48cvC2 FKePkp+hdszfelaG4ampaYI=type: kubernetes.io/tls 还可以这样创建secret： 1kubectl create secret tls testsecret-tls --key tls.key --cert tls.crt -n ingress-nginx 3、在Ingress中引用 Secretsecret-ingress.yaml 123456789101112131415161718apiVersion: networking.k8s.io/v1beta1kind: Ingressmetadata: name: secret-ingress namespace: ingress-nginxspec: tls: - hosts: - tomcat.nedy.com secretName: testsecret-tls #默认ingress controller证书将该句注释掉 rules: - host: tomcat.nedy.com http: paths: - path: / backend: serviceName: myweb servicePort: 80 注意这里 4、访问测试1234567891011121314151617[root@k8s-master tomcat]# curl -Ik http://tomcat.nedy.com HTTP/1.1 308 Permanent Redirect Server: openresty/1.15.8.1Date: Thu, 08 Aug 2019 11:04:42 GMTContent-Type: text/htmlContent-Length: 177Connection: keep-aliveLocation: https://tomcat.nedy.com/ #会重定向到 https://tomcat.nedy.com[root@k8s-master tomcat]# curl -Ik https://tomcat.nedy.comHTTP/1.1 200 OKServer: openresty/1.15.8.1Date: Thu, 08 Aug 2019 11:04:46 GMTContent-Type: text/html;charset=UTF-8Connection: keep-aliveVary: Accept-EncodingStrict-Transport-Security: max-age=15724800; includeSubDomains 5、其他 创建证书和secret 12openssl req -x509 -nodes -days 5000 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj \"/CN=tomcat.test.com\"kubectl create secret tls testsecret-tls -n ingress-nginx --key tls.key --cert tls.crt 使用 secret-ingress.yaml 1234567891011121314151617181920212223242526272829303132333435apiVersion: networking.k8s.io/v1beta1kind: Ingressmetadata: name: secret-ingress namespace: ingress-nginx annotations: nginx.ingress.kubernetes.io/rewrite-target: /spec: tls: - hosts: - tomcat.test.com secretName: testsecret-tls rules: - host: tomcat.test.com http: paths: - path: / backend: serviceName: myweb servicePort: 80 - path: /bar backend: serviceName: myweb2 servicePort: 80 - host: tomcat.nedy.com #这里我没有配置该域名AC也可以通过https访问 http: paths: - path: / backend: serviceName: myweb servicePort: 80 - path: /bar backend: serviceName: myweb2 servicePort: 80 测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253[root@k8s-master ingress]# curl -Ik https://tomcat.test.comHTTP/1.1 200 OKServer: openresty/1.15.8.1Date: Fri, 09 Aug 2019 02:46:57 GMTContent-Type: text/html;charset=UTF-8Connection: keep-aliveVary: Accept-EncodingStrict-Transport-Security: max-age=15724800; includeSubDomains[root@k8s-master ingress]# curl -Ik http://tomcat.test.comHTTP/1.1 308 Permanent RedirectServer: openresty/1.15.8.1Date: Fri, 09 Aug 2019 02:58:28 GMTContent-Type: text/htmlContent-Length: 177Connection: keep-aliveLocation: https://tomcat.test.com/ #会重定向到https://tomcat.test.com/[root@k8s-master ingress]# curl -Ik https://tomcat.test.com/barHTTP/1.1 200Server: openresty/1.15.8.1Date: Fri, 09 Aug 2019 02:57:39 GMTContent-Type: text/html;charset=UTF-8Connection: keep-aliveVary: Accept-EncodingStrict-Transport-Security: max-age=15724800; includeSubDomains[root@k8s-master ingress]# curl -Ik https://tomcat.nedy.comHTTP/1.1 200 OKServer: openresty/1.15.8.1Date: Fri, 09 Aug 2019 02:47:02 GMTContent-Type: text/html;charset=UTF-8Connection: keep-aliveVary: Accept-EncodingStrict-Transport-Security: max-age=15724800; includeSubDomains[root@k8s-master ingress]# curl -Ik http://tomcat.nedy.comHTTP/1.1 308 Permanent RedirectServer: openresty/1.15.8.1Date: Fri, 09 Aug 2019 02:47:08 GMTContent-Type: text/htmlContent-Length: 177Connection: keep-aliveLocation: https://tomcat.nedy.com/[root@k8s-master ingress]# curl -Ik https://tomcat.nedy.com/barHTTP/1.1 200 OKServer: openresty/1.15.8.1Date: Fri, 09 Aug 2019 02:47:16 GMTContent-Type: text/html;charset=UTF-8Connection: keep-aliveVary: Accept-EncodingStrict-Transport-Security: max-age=15724800; includeSubDomains 这里有个疑惑：没有为tomcat.nedy.com配置证书，但是依然可以通过https访问 6、IP和域名访问是否为同一服务使用上面的例子 其中myweb使用的tomcat版本是tomcat-8.0，myweb2使用的tomcat版本是tomcat-9.0 1) secret-ingress.yaml 123456789101112131415161718192021222324apiVersion: networking.k8s.io/v1beta1kind: Ingressmetadata: name: secret-ingress namespace: ingress-nginx annotations: nginx.ingress.kubernetes.io/rewrite-target: /spec: tls: - hosts: - tomcat.test.com secretName: testsecret-tls rules: - host: tomcat.test.com http: paths: - path: / backend: serviceName: myweb servicePort: 80 - path: /bar backend: serviceName: myweb2 servicePort: 80 验证： 12345678910[root@k8s-master ingress]# curl -k https://tomcat.test.com | grep Tomcat\\/ | grep h1 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 11266 0 11266 0 0 184k 0 --:--:-- --:--:-- --:--:-- 189k &lt;h1&gt;Apache Tomcat/8.0.53&lt;/h1&gt;[root@k8s-master ingress]# curl -k https://tomcat.test.com/bar | grep Tomcat\\/ | grep h1 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 11184 0 11184 0 0 252k 0 --:--:-- --:--:-- --:--:-- 260k &lt;h1&gt;Apache Tomcat/9.0.22&lt;/h1&gt; 2) secret-ingress.yaml 12345678910111213141516171819202122232425262728293031323334apiVersion: networking.k8s.io/v1beta1kind: Ingressmetadata: name: secret-ingress namespace: ingress-nginx annotations: nginx.ingress.kubernetes.io/rewrite-target: /spec: tls: - hosts: - tomcat.test.com secretName: testsecret-tls rules: - host: tomcat.test.com http: paths: - path: / backend: serviceName: myweb servicePort: 80 - path: /bar backend: serviceName: myweb2 servicePort: 80 - http: paths: - path: / backend: serviceName: myweb2 servicePort: 80 - path: /bar backend: serviceName: myweb servicePort: 80 验证 1234567891011121314151617181920[root@k8s-master ingress]# curl -k https://tomcat.test.com | grep Tomcat\\/ | grep h1 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 11266 0 11266 0 0 188k 0 --:--:-- --:--:-- --:--:-- 193k &lt;h1&gt;Apache Tomcat/8.0.53&lt;/h1&gt;[root@k8s-master ingress]# curl -k https://tomcat.test.com/bar | grep Tomcat\\/ | grep h1 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 11184 0 11184 0 0 190k 0 --:--:-- --:--:-- --:--:-- 191k &lt;h1&gt;Apache Tomcat/9.0.22&lt;/h1&gt;[root@k8s-master ingress]# curl -k https://172.25.21.66 | grep Tomcat\\/ | grep h1 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 11184 0 11184 0 0 235k 0 --:--:-- --:--:-- --:--:-- 237k &lt;h1&gt;Apache Tomcat/9.0.22&lt;/h1&gt;[root@k8s-master ingress]# curl -k https://172.25.21.66/bar | grep Tomcat\\/ | grep h1 % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 11266 0 11266 0 0 268k 0 --:--:-- --:--:-- --:--:-- 275k &lt;h1&gt;Apache Tomcat/8.0.53&lt;/h1&gt; 结论：相同的IP路径和域名路径可以转发不同的服务，通过相同路径的IP和域名访问的结果不一样，因为对应的服务不同，即IP和域名不对应。","categories":[{"name":"Kubernetes","slug":"Kubernetes","permalink":"http://xuqilong.com/categories/Kubernetes/"}],"tags":[{"name":"ingress","slug":"ingress","permalink":"http://xuqilong.com/tags/ingress/"}]}]}